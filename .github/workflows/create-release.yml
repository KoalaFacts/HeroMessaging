name: Create Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., 1.0.0 or 1.0.0-beta.1)'
        required: true
        type: string
      commit_sha:
        description: 'Commit SHA to release (leave empty for latest main)'
        required: false
        type: string
      prerelease:
        description: 'Mark as pre-release'
        required: false
        default: false
        type: boolean
      draft:
        description: 'Create as draft release'
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  actions: read
  pull-requests: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

env:
  DOTNET_NOLOGO: true
  CI_WORKFLOW_NAME: 'ci.yml'  # CI workflow to validate before release

jobs:
  validate-and-prepare:
    name: Validate Release Parameters
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      version: ${{ steps.validate.outputs.version }}
      tag: ${{ steps.validate.outputs.tag }}
      commit_sha: ${{ steps.validate.outputs.commit_sha }}
      workflow_run_id: ${{ steps.find-workflow.outputs.run_id }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          ref: ${{ github.event.inputs.commit_sha || 'main' }}
          fetch-depth: 0

      - name: Validate version format
        id: validate
        run: |
          VERSION="${{ github.event.inputs.version }}"

          # Remove 'v' prefix if present
          VERSION=${VERSION#v}

          # Validate semantic version format
          if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9\.]+)?$ ]]; then
            echo "âŒ Invalid version format: $VERSION"
            echo "Expected format: X.Y.Z or X.Y.Z-prerelease"
            echo "Examples: 1.0.0, 1.0.0-beta.1, 1.0.0-rc.2"
            exit 1
          fi

          TAG="v${VERSION}"

          # Check if tag already exists
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "âŒ Tag $TAG already exists!"
            echo "Use a different version number or delete the existing tag."
            exit 1
          fi

          # Get commit SHA
          COMMIT_SHA="${{ github.event.inputs.commit_sha }}"
          if [ -z "$COMMIT_SHA" ]; then
            COMMIT_SHA=$(git rev-parse HEAD)
            echo "No commit SHA provided, using latest main: $COMMIT_SHA"
          fi

          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "commit_sha=${COMMIT_SHA}" >> $GITHUB_OUTPUT
          echo "âœ… Version validated: ${VERSION}"
          echo "âœ… Tag will be created: ${TAG}"
          echo "âœ… Commit SHA: ${COMMIT_SHA}"

      - name: Find successful workflow run
        id: find-workflow
        uses: actions/github-script@v8
        env:
          CI_WORKFLOW: ${{ env.CI_WORKFLOW_NAME }}
        with:
          script: |
            const commitSha = '${{ steps.validate.outputs.commit_sha }}';
            const ciWorkflow = process.env.CI_WORKFLOW;

            console.log(`Looking for successful ${ciWorkflow} run for commit ${commitSha}`);

            // Find successful CI workflow run for this commit
            const runs = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: ciWorkflow,
              status: 'success',
              head_sha: commitSha,
              per_page: 1
            });

            if (runs.data.workflow_runs.length === 0) {
              core.setFailed(`âŒ No successful CI workflow run found for commit ${commitSha}`);
              core.setFailed('Make sure the commit has been pushed to main and all tests have passed.');
              return;
            }

            const run = runs.data.workflow_runs[0];
            console.log(`âœ… Found workflow run: ${run.id}`);
            console.log(`   Status: ${run.status}`);
            console.log(`   Conclusion: ${run.conclusion}`);
            console.log(`   Run URL: ${run.html_url}`);

            core.setOutput('run_id', run.id);

  download-packages:
    name: Download Pre-built Packages
    needs: validate-and-prepare
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Download packages from CI workflow
        uses: actions/download-artifact@v6
        with:
          name: release-packages-${{ needs.validate-and-prepare.outputs.commit_sha }}
          path: ./release-packages
          run-id: ${{ needs.validate-and-prepare.outputs.workflow_run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: List downloaded packages
        run: |
          echo "ðŸ“¦ Downloaded packages from CI workflow:"
          ls -lh ./release-packages/
          echo ""
          echo "These packages were built and tested in workflow run:"
          echo "${{ needs.validate-and-prepare.outputs.workflow_run_id }}"

      - name: Rename packages with release version
        run: |
          VERSION="${{ needs.validate-and-prepare.outputs.version }}"

          cd ./release-packages

          echo "Renaming packages to version: ${VERSION}"
          echo ""

          # Rename packages from CI version to release version
          # CI format: {PackageId}.{version}-ci.{metadata}.{ext}
          # Release format: {PackageId}.{version}.{ext}
          for file in *.nupkg *.snupkg 2>/dev/null; do
            # Skip if no files match
            [ -e "$file" ] || continue

            # Extract package ID and extension
            # Match pattern: anything before version-ci, then version, then extension
            if [[ "$file" =~ ^(.+)\.[0-9]+\.[0-9]+\.[0-9]+-ci\.(.+)\.(nupkg|snupkg)$ ]]; then
              package_id="${BASH_REMATCH[1]}"
              ext="${BASH_REMATCH[3]}"
              newname="${package_id}.${VERSION}.${ext}"

              echo "âœ“ Renaming: $file â†’ $newname"
              mv "$file" "$newname"
            else
              echo "âš  Warning: $file doesn't match expected CI package format, skipping"
            fi
          done

          echo ""
          echo "ðŸ“¦ Final packages:"
          ls -lh *.nupkg *.snupkg 2>/dev/null || echo "No packages found!"

      - name: Setup .NET for signing
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: |
            8.0.x
            9.0.x
            10.0.x

      - name: Sign NuGet packages
        env:
          SIGNING_CERT_BASE64: ${{ secrets.NUGET_SIGNING_CERT_BASE64 }}
          SIGNING_CERT_PASSWORD: ${{ secrets.NUGET_SIGNING_CERT_PASSWORD }}
          TIMESTAMP_URL: http://timestamp.digicert.com
        run: |
          cd ./release-packages

          # Check if signing certificate is configured
          if [ -z "$SIGNING_CERT_BASE64" ]; then
            echo "â„¹ï¸ Package signing skipped - no certificate configured"
            echo "To enable package signing, configure the following secrets:"
            echo "  - NUGET_SIGNING_CERT_BASE64"
            echo "  - NUGET_SIGNING_CERT_PASSWORD"
            exit 0
          fi

          echo "ðŸ” Setting up code signing certificate..."

          # Decode certificate from base64
          echo "$SIGNING_CERT_BASE64" | base64 -d > signing-cert.pfx

          # Install NuGet sign tool
          dotnet tool install --global NuGet.CommandLine || dotnet tool update --global NuGet.CommandLine

          # Sign all .nupkg files
          for pkg in *.nupkg; do
            if [ -f "$pkg" ]; then
              echo "Signing: $pkg"
              dotnet nuget sign "$pkg" \
                --certificate-path signing-cert.pfx \
                --certificate-password "$SIGNING_CERT_PASSWORD" \
                --timestamper "$TIMESTAMP_URL" \
                --overwrite

              # Verify signature
              dotnet nuget verify --all "$pkg" && echo "âœ… Verified: $pkg" || echo "âš ï¸ Verification failed: $pkg"
            fi
          done

          # Clean up certificate file
          rm -f signing-cert.pfx

          echo "âœ… Package signing complete"

      - name: Package signing status
        run: |
          cd ./release-packages

          if [ -z "${{ secrets.NUGET_SIGNING_CERT_BASE64 }}" ]; then
            echo "â„¹ï¸ Package signing skipped - no certificate configured"
            echo "To enable package signing:"
            echo "  1. Generate or obtain a code signing certificate (e.g., from DigiCert, Sectigo)"
            echo "  2. Export as .pfx file with password"
            echo "  3. Convert to base64: base64 -w 0 certificate.pfx > cert.base64"
            echo "  4. Add secrets to repository:"
            echo "     - NUGET_SIGNING_CERT_BASE64: <base64 content>"
            echo "     - NUGET_SIGNING_CERT_PASSWORD: <certificate password>"
          else
            echo "âœ… Packages have been signed with code signing certificate"
          fi

      - name: Upload renamed packages
        uses: actions/upload-artifact@v6
        with:
          name: release-packages-${{ needs.validate-and-prepare.outputs.version }}
          path: ./release-packages/*
          retention-days: 90

  create-release:
    name: Create GitHub Release
    needs: [validate-and-prepare, download-packages]
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.validate-and-prepare.outputs.commit_sha }}
          fetch-depth: 0

      - name: Download packages
        uses: actions/download-artifact@v6
        with:
          name: release-packages-${{ needs.validate-and-prepare.outputs.version }}
          path: ./release-packages

      - name: Generate release notes
        id: release-notes
        run: |
          VERSION="${{ needs.validate-and-prepare.outputs.version }}"
          TAG="${{ needs.validate-and-prepare.outputs.tag }}"
          COMMIT_SHA="${{ needs.validate-and-prepare.outputs.commit_sha }}"

          # Get the last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          # Generate release notes
          cat > release-notes.md << EOF
          ## NuGet Packages

          - [HeroMessaging v${VERSION}](https://www.nuget.org/packages/HeroMessaging/${VERSION})
          - [HeroMessaging.Abstractions v${VERSION}](https://www.nuget.org/packages/HeroMessaging.Abstractions/${VERSION})

          ## Installation

          \`\`\`bash
          dotnet add package HeroMessaging --version ${VERSION}
          \`\`\`

          ## What's Changed

          EOF

          # Add commit log since last tag
          if [ -n "$LAST_TAG" ]; then
            echo "### Commits since ${LAST_TAG}" >> release-notes.md
            echo "" >> release-notes.md
            git log ${LAST_TAG}..${COMMIT_SHA} --pretty=format:"- %s (%h)" >> release-notes.md
            echo "" >> release-notes.md
          else
            echo "Initial release" >> release-notes.md
          fi

          echo "" >> release-notes.md
          echo "---" >> release-notes.md
          echo "" >> release-notes.md
          echo "**Release commit**: ${COMMIT_SHA}" >> release-notes.md
          echo "**Built by**: [CI Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ needs.validate-and-prepare.outputs.workflow_run_id }})" >> release-notes.md

          if [ -n "$LAST_TAG" ]; then
            echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${LAST_TAG}...${TAG}" >> release-notes.md
          fi

      - name: Create GitHub Release
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const version = '${{ needs.validate-and-prepare.outputs.version }}';
            const tag = '${{ needs.validate-and-prepare.outputs.tag }}';
            const commitSha = '${{ needs.validate-and-prepare.outputs.commit_sha }}';
            const isPrerelease = ${{ github.event.inputs.prerelease }};
            const isDraft = ${{ github.event.inputs.draft }};

            // Read release notes
            const releaseNotes = fs.readFileSync('release-notes.md', 'utf8');

            // Create the release
            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tag,
              name: `Release ${version}`,
              body: releaseNotes,
              draft: isDraft,
              prerelease: isPrerelease,
              target_commitish: commitSha
            });

            console.log(`âœ… Created release: ${release.data.html_url}`);

            // Upload packages as release assets
            const packagesDir = './release-packages';
            const files = fs.readdirSync(packagesDir);

            for (const file of files) {
              if (file.endsWith('.nupkg') || file.endsWith('.snupkg')) {
                const filePath = path.join(packagesDir, file);
                const stats = fs.statSync(filePath);
                const fileContent = fs.readFileSync(filePath);

                console.log(`ðŸ“¤ Uploading ${file} (${stats.size} bytes)...`);

                await github.rest.repos.uploadReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: release.data.id,
                  name: file,
                  data: fileContent
                });

                console.log(`âœ… Uploaded ${file}`);
              }
            }

            core.setOutput('release-id', release.data.id);
            core.setOutput('release-url', release.data.html_url);

      - name: Summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## âœ… Release Created Successfully

          **Version**: ${{ needs.validate-and-prepare.outputs.version }}
          **Tag**: ${{ needs.validate-and-prepare.outputs.tag }}
          **Commit**: ${{ needs.validate-and-prepare.outputs.commit_sha }}
          **Pre-release**: ${{ github.event.inputs.prerelease }}
          **Draft**: ${{ github.event.inputs.draft }}

          ### ðŸ“¦ Packages Included

          Built from [CI Workflow Run #${{ needs.validate-and-prepare.outputs.workflow_run_id }}](https://github.com/${{ github.repository }}/actions/runs/${{ needs.validate-and-prepare.outputs.workflow_run_id }})

          ### ðŸš€ Next Steps

          EOF

          if [ "${{ github.event.inputs.draft }}" = "false" ]; then
            cat >> $GITHUB_STEP_SUMMARY << EOF
          The **Publish to NuGet** workflow will automatically trigger and publish packages to:
          - NuGet.org via Trusted Publishing
          - GitHub Packages

          No rebuild or re-test needed - using pre-built artifacts from CI!
          EOF
          else
            cat >> $GITHUB_STEP_SUMMARY << EOF
          This is a **draft release**. To publish:
          1. Review the release
          2. Edit and publish the release
          3. The Publish to NuGet workflow will then trigger automatically
          EOF
          fi
