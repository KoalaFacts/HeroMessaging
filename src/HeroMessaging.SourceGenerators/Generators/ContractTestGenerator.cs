// Copyright (c) HeroMessaging Contributors. All rights reserved.

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace HeroMessaging.SourceGenerators.Generators;

/// <summary>
/// Generates contract tests for messages to ensure backward compatibility.
/// Creates snapshot tests, schema validation, and roundtrip serialization tests.
/// </summary>
[Generator]
public class ContractTestGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find classes/records with [GenerateContractTests]
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsContractTestCandidate(node),
                transform: static (ctx, _) => GetContractInfo(ctx))
            .Where(static info => info is not null);

        // Generate contract tests
        context.RegisterSourceOutput(classDeclarations, (spc, contractInfo) =>
        {
            if (contractInfo is null) return;

            var source = GenerateContractTests(contractInfo.Value);
            spc.AddSource($"{contractInfo.Value.TypeName}.ContractTests.g.cs",
                SourceText.From(source, Encoding.UTF8));
        });
    }

    private static bool IsContractTestCandidate(SyntaxNode node)
    {
        return (node is ClassDeclarationSyntax || node is RecordDeclarationSyntax) &&
               ((TypeDeclarationSyntax)node).AttributeLists.Count > 0;
    }

    private static ContractInfo? GetContractInfo(GeneratorSyntaxContext context)
    {
        var typeDecl = (TypeDeclarationSyntax)context.Node;

        // Check for [GenerateContractTests] attribute
        var hasAttribute = typeDecl.AttributeLists
            .SelectMany(al => al.Attributes)
            .Any(a => a.Name.ToString().Contains("GenerateContractTests"));

        if (!hasAttribute) return null;

        var namespaceDecl = typeDecl.FirstAncestorOrSelf<NamespaceDeclarationSyntax>();
        var namespaceName = namespaceDecl?.Name.ToString() ?? "Global";

        var properties = new List<PropertyContractInfo>();

        foreach (var member in typeDecl.Members)
        {
            if (member is PropertyDeclarationSyntax propDecl)
            {
                var isRequired = propDecl.AttributeLists
                    .SelectMany(al => al.Attributes)
                    .Any(a => a.Name.ToString().Contains("ContractRequired"));

                var isDeprecated = propDecl.AttributeLists
                    .SelectMany(al => al.Attributes)
                    .Any(a => a.Name.ToString().Contains("ContractDeprecated"));

                properties.Add(new PropertyContractInfo
                {
                    Name = propDecl.Identifier.Text,
                    Type = propDecl.Type.ToString(),
                    IsRequired = isRequired,
                    IsDeprecated = isDeprecated
                });
            }
        }

        // Find sample methods
        var samples = new List<SampleInfo>();
        foreach (var member in typeDecl.Members)
        {
            if (member is MethodDeclarationSyntax methodDecl)
            {
                var sampleAttr = methodDecl.AttributeLists
                    .SelectMany(al => al.Attributes)
                    .FirstOrDefault(a => a.Name.ToString().Contains("ContractSample"));

                if (sampleAttr != null)
                {
                    var sampleName = GetAttributeStringArgument(sampleAttr, 0) ?? methodDecl.Identifier.Text;
                    samples.Add(new SampleInfo
                    {
                        Name = sampleName,
                        MethodName = methodDecl.Identifier.Text
                    });
                }
            }
        }

        return new ContractInfo
        {
            Namespace = namespaceName,
            TypeName = typeDecl.Identifier.Text,
            Properties = properties,
            Samples = samples,
            Version = "v1.0" // TODO: Extract from attribute
        };
    }

    private static string? GetAttributeStringArgument(AttributeSyntax attr, int position)
    {
        if (attr.ArgumentList == null || attr.ArgumentList.Arguments.Count <= position)
            return null;

        return attr.ArgumentList.Arguments[position].Expression.ToString().Trim('"');
    }

    private static string GenerateContractTests(ContractInfo info)
    {
        var sb = new StringBuilder();

        sb.AppendLine($@"// <auto-generated/>
#nullable enable

using System;
using System.Text.Json;
using Xunit;

namespace {info.Namespace}.Contract.Tests;

/// <summary>
/// Contract tests for {info.TypeName} to ensure backward compatibility.
/// These tests will fail if the message schema changes in a breaking way.
/// </summary>
public class {info.TypeName}ContractTests
{{
    private static readonly JsonSerializerOptions _jsonOptions = new()
    {{
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        WriteIndented = true
    }};

    #region Schema Snapshot Tests

    [Fact]
    public void {info.TypeName}_SchemaSnapshot_HasNotChanged()
    {{
        // This test ensures the message schema hasn't changed unexpectedly
        var expectedProperties = new[]
        {{");

        foreach (var prop in info.Properties)
        {
            sb.AppendLine($"            (\"{prop.Name}\", typeof({prop.Type})),");
        }

        sb.AppendLine(@"        };

        var actualProperties = typeof({info.TypeName})
            .GetProperties()
            .Select(p => (p.Name, p.PropertyType))
            .OrderBy(p => p.Name)
            .ToArray();

        var expectedSorted = expectedProperties.OrderBy(p => p.Item1).ToArray();

        Assert.Equal(expectedSorted.Length, actualProperties.Length);

        for (int i = 0; i < expectedSorted.Length; i++)
        {
            Assert.Equal(expectedSorted[i].Item1, actualProperties[i].Name);
            Assert.Equal(expectedSorted[i].Item2, actualProperties[i].PropertyType);
        }
    }");

        // Generate required property tests
        var requiredProperties = info.Properties.Where(p => p.IsRequired).ToList();
        if (requiredProperties.Any())
        {
            sb.AppendLine();
            sb.AppendLine($@"    [Fact]
    public void {info.TypeName}_RequiredProperties_ArePresent()
    {{
        // Breaking change: Required properties must not be removed");

            foreach (var prop in requiredProperties)
            {
                sb.AppendLine($@"        Assert.NotNull(typeof({info.TypeName}).GetProperty(""{prop.Name}""));");
            }

            sb.AppendLine("    }");
        }

        sb.AppendLine();
        sb.AppendLine($@"    #endregion

    #region Roundtrip Serialization Tests");

        // Generate roundtrip tests for samples
        if (info.Samples.Any())
        {
            foreach (var sample in info.Samples)
            {
                sb.AppendLine();
                sb.AppendLine($@"    [Fact]
    public void {info.TypeName}_{sample.Name}_RoundtripSerialization_Succeeds()
    {{
        // Arrange
        var original = {info.TypeName}.{sample.MethodName}();

        // Act - Serialize to JSON
        var json = JsonSerializer.Serialize(original, _jsonOptions);

        // Deserialize back
        var deserialized = JsonSerializer.Deserialize<{info.TypeName}>(json, _jsonOptions);

        // Assert - Should match original
        Assert.NotNull(deserialized);");

                foreach (var prop in info.Properties)
                {
                    sb.AppendLine($"        Assert.Equal(original.{prop.Name}, deserialized.{prop.Name});");
                }

                sb.AppendLine("    }");
            }
        }
        else
        {
            // Generate generic roundtrip test
            sb.AppendLine();
            sb.AppendLine($@"    [Fact]
    public void {info.TypeName}_RoundtripSerialization_Succeeds()
    {{
        // Arrange
        var original = new {info.TypeName}
        {{");

            foreach (var prop in info.Properties)
            {
                sb.AppendLine($"            {prop.Name} = default({prop.Type})!,");
            }

            sb.AppendLine(@"        };

        // Act
        var json = JsonSerializer.Serialize(original, _jsonOptions);
        var deserialized = JsonSerializer.Deserialize<{info.TypeName}>(json, _jsonOptions);

        // Assert
        Assert.NotNull(deserialized);");

            foreach (var prop in info.Properties)
            {
                sb.AppendLine($"        Assert.Equal(original.{prop.Name}, deserialized.{prop.Name});");
            }

            sb.AppendLine("    }");
        }

        sb.AppendLine();
        sb.AppendLine($@"    #endregion

    #region Backward Compatibility Tests

    [Fact]
    public void {info.TypeName}_CanDeserialize_MinimalValidJson()
    {{
        // This test ensures old messages with minimal fields can still be deserialized
        // Even if new optional fields are added, old messages should work

        var minimalJson = @""{{");

        // Include only required properties in minimal JSON
        var firstRequired = true;
        foreach (var prop in info.Properties.Where(p => p.IsRequired))
        {
            if (!firstRequired) sb.Append(",");
            var camelCaseName = ToCamelCase(prop.Name);
            var defaultValue = GetDefaultJsonValue(prop.Type);
            sb.AppendLine($@"
  \""{camelCaseName}\"": {defaultValue}");
            firstRequired = false;
        }

        sb.AppendLine(@"}}"";

        // Act
        var deserialized = JsonSerializer.Deserialize<{info.TypeName}>(minimalJson, _jsonOptions);

        // Assert
        Assert.NotNull(deserialized);
    }

    [Fact]
    public void {info.TypeName}_CanDeserialize_WithExtraFields()
    {{
        // Forward compatibility: Should ignore unknown fields from newer versions
        var jsonWithExtra = @""{{");

        // Include all properties plus an extra one
        firstRequired = true;
        foreach (var prop in info.Properties.Take(Math.Min(2, info.Properties.Count)))
        {
            if (!firstRequired) sb.Append(",");
            var camelCaseName = ToCamelCase(prop.Name);
            var defaultValue = GetDefaultJsonValue(prop.Type);
            sb.AppendLine($@"
  \""{camelCaseName}\"": {defaultValue}");
            firstRequired = false;
        }

        sb.AppendLine(@",
  ""unknownField"": ""should-be-ignored""
}}"";

        // Act
        var deserialized = JsonSerializer.Deserialize<{info.TypeName}>(jsonWithExtra, _jsonOptions);

        // Assert - Should not throw, extra fields ignored
        Assert.NotNull(deserialized);
    }

    #endregion

    #region JSON Schema Tests

    [Fact]
    public void {info.TypeName}_SerializedJson_HasExpectedStructure()
    {{");

        if (info.Samples.Any())
        {
            var firstSample = info.Samples.First();
            sb.AppendLine($@"        // Arrange
        var message = {info.TypeName}.{firstSample.MethodName}();");
        }
        else
        {
            sb.AppendLine($@"        // Arrange
        var message = new {info.TypeName}
        {{");

            foreach (var prop in info.Properties)
            {
                sb.AppendLine($"            {prop.Name} = default({prop.Type})!,");
            }

            sb.AppendLine("        };");
        }

        sb.AppendLine(@"
        // Act
        var json = JsonSerializer.Serialize(message, _jsonOptions);
        using var document = JsonDocument.Parse(json);
        var root = document.RootElement;

        // Assert - All properties are present in JSON");

        foreach (var prop in info.Properties)
        {
            var camelName = ToCamelCase(prop.Name);
            sb.AppendLine($"        Assert.True(root.TryGetProperty(\"{camelName}\", out _), \"Property '{camelName}' should be present in JSON\");");
        }

        sb.AppendLine(@"    }

    #endregion

    #region Version Information

    [Fact]
    public void {info.TypeName}_ContractVersion_IsDocumented()
    {{
        // This test documents the contract version
        const string currentVersion = ""{info.Version}"";

        // If this test fails, update the version and document breaking changes
        Assert.Equal(""{info.Version}"", currentVersion);
    }}

    #endregion
}}");

        return sb.ToString();
    }

    private static string ToCamelCase(string text)
    {
        if (string.IsNullOrEmpty(text)) return text;
        return char.ToLowerInvariant(text[0]) + text.Substring(1);
    }

    private static string GetDefaultJsonValue(string type)
    {
        type = type.TrimEnd('?'); // Remove nullable marker

        if (type == "string") return "\"\"";
        if (type == "int" || type == "Int32") return "0";
        if (type == "long" || type == "Int64") return "0";
        if (type == "decimal") return "0.0";
        if (type == "double" || type == "Double") return "0.0";
        if (type == "float" || type == "Single") return "0.0";
        if (type == "bool" || type == "Boolean") return "false";
        if (type == "DateTime") return "\"2025-01-01T00:00:00Z\"";
        if (type == "DateTimeOffset") return "\"2025-01-01T00:00:00Z\"";
        if (type == "Guid") return "\"00000000-0000-0000-0000-000000000000\"";
        if (type.StartsWith("List<") || type.Contains("[]")) return "[]";

        return "null";
    }

    private struct ContractInfo
    {
        public string Namespace { get; set; }
        public string TypeName { get; set; }
        public List<PropertyContractInfo> Properties { get; set; }
        public List<SampleInfo> Samples { get; set; }
        public string Version { get; set; }
    }

    private struct PropertyContractInfo
    {
        public string Name { get; set; }
        public string Type { get; set; }
        public bool IsRequired { get; set; }
        public bool IsDeprecated { get; set; }
    }

    private struct SampleInfo
    {
        public string Name { get; set; }
        public string MethodName { get; set; }
    }
}
