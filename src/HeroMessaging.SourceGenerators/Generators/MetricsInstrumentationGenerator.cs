// Copyright (c) HeroMessaging Contributors. All rights reserved.

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace HeroMessaging.SourceGenerators.Generators;

/// <summary>
/// Generates metrics instrumentation for methods decorated with [InstrumentMethod].
/// Creates partial method implementations with counters, histograms, and gauges.
/// </summary>
[Generator]
public class MetricsInstrumentationGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find classes with [GenerateMetrics]
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsClassWithMetricsAttribute(node),
                transform: static (ctx, _) => GetClassInfo(ctx))
            .Where(static c => c is not null);

        // Generate metrics infrastructure
        context.RegisterSourceOutput(classDeclarations, (spc, classInfo) =>
        {
            if (classInfo is null) return;

            var source = GenerateMetricsInfrastructure(classInfo.Value);
            spc.AddSource($"{classInfo.Value.ClassName}.Metrics.g.cs",
                SourceText.From(source, Encoding.UTF8));
        });

        // Find methods with [InstrumentMethod]
        var methodDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsMethodWithInstrumentAttribute(node),
                transform: static (ctx, _) => GetInstrumentedMethodInfo(ctx))
            .Where(static m => m is not null);

        // Generate instrumented methods
        context.RegisterSourceOutput(methodDeclarations, (spc, method) =>
        {
            if (method is null) return;

            var source = GenerateInstrumentedMethod(method.Value);
            spc.AddSource($"{method.Value.ClassName}.{method.Value.MethodName}.Metrics.g.cs",
                SourceText.From(source, Encoding.UTF8));
        });
    }

    private static bool IsClassWithMetricsAttribute(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDecl &&
               classDecl.AttributeLists.Count > 0 &&
               classDecl.Modifiers.Any(m => m.ValueText == "partial");
    }

    private static bool IsMethodWithInstrumentAttribute(SyntaxNode node)
    {
        return node is MethodDeclarationSyntax method &&
               method.AttributeLists.Count > 0 &&
               method.Modifiers.Any(m => m.ValueText == "partial");
    }

    private static ClassInfo? GetClassInfo(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;

        var namespaceDeclaration = classDecl.FirstAncestorOrSelf<NamespaceDeclarationSyntax>();
        var namespaceName = namespaceDeclaration?.Name.ToString() ?? "Global";

        var meterName = $"{namespaceName}.{classDecl.Identifier.Text}";

        return new ClassInfo
        {
            Namespace = namespaceName,
            ClassName = classDecl.Identifier.Text,
            MeterName = meterName
        };
    }

    private static InstrumentedMethodInfo? GetInstrumentedMethodInfo(GeneratorSyntaxContext context)
    {
        var method = (MethodDeclarationSyntax)context.Node;

        var classDeclaration = method.FirstAncestorOrSelf<ClassDeclarationSyntax>();
        if (classDeclaration is null) return null;

        var namespaceDeclaration = classDeclaration.FirstAncestorOrSelf<NamespaceDeclarationSyntax>();
        var namespaceName = namespaceDeclaration?.Name.ToString() ?? "Global";

        var tagParameters = method.ParameterList.Parameters
            .Where(p => p.AttributeLists
                .SelectMany(al => al.Attributes)
                .Any(a => a.Name.ToString().Contains("MetricTag")))
            .Select(p => p.Identifier.Text)
            .ToList();

        return new InstrumentedMethodInfo
        {
            Namespace = namespaceName,
            ClassName = classDeclaration.Identifier.Text,
            MethodName = method.Identifier.Text,
            ReturnType = method.ReturnType.ToString(),
            Parameters = [.. method.ParameterList.Parameters
                .Select(p => new ParameterInfo
                {
                    Type = p.Type?.ToString() ?? "object",
                    Name = p.Identifier.Text
                })],
            TagParameters = tagParameters,
            IsAsync = method.Modifiers.Any(m => m.ValueText == "async")
        };
    }

    private static string GenerateMetricsInfrastructure(ClassInfo classInfo)
    {
        var sb = new StringBuilder();
        sb.AppendLine($@"// <auto-generated/>
#nullable enable

using System.Diagnostics.Metrics;

namespace {classInfo.Namespace};

public partial class {classInfo.ClassName}
{{
    // Generated Meter for metrics
    private static readonly Meter _meter = new Meter(""{classInfo.MeterName}"", ""1.0.0"");

    // Counters
    private static readonly Counter<long> _methodCallsCounter =
        _meter.CreateCounter<long>(""method.calls"", ""count"", ""Total method calls"");

    private static readonly Counter<long> _methodErrorsCounter =
        _meter.CreateCounter<long>(""method.errors"", ""count"", ""Total method errors"");

    // Histograms
    private static readonly Histogram<double> _methodDurationHistogram =
        _meter.CreateHistogram<double>(""method.duration"", ""ms"", ""Method execution duration"");
}}");

        return sb.ToString();
    }

    private static string GenerateInstrumentedMethod(InstrumentedMethodInfo method)
    {
        var hasReturn = method.ReturnType != "void" && method.ReturnType != "Task";
        var parameters = string.Join(", ", method.Parameters.Select(p => $"{p.Type} {p.Name}"));
        var parameterNames = string.Join(", ", method.Parameters.Select(p => p.Name));

        var tags = new StringBuilder();
        tags.AppendLine("        var tags = new TagList");
        tags.AppendLine("        {");
        tags.AppendLine($"            {{ \"method\", \"{method.MethodName}\" }},");
        tags.AppendLine($"            {{ \"class\", \"{method.ClassName}\" }}");

        foreach (var tagParam in method.TagParameters)
        {
            tags.AppendLine($"            , {{ \"{ToSnakeCase(tagParam)}\", {tagParam}?.ToString() ?? \"null\" }}");
        }

        tags.AppendLine("        };");

        var sb = new StringBuilder();
        sb.AppendLine($@"// <auto-generated/>
#nullable enable

using System;
using System.Diagnostics;
using System.Diagnostics.Metrics;
using System.Threading.Tasks;

namespace {method.Namespace};

public partial class {method.ClassName}
{{
    // Generated metrics instrumentation for {method.MethodName}
    public{(method.IsAsync ? " async" : "")} partial {method.ReturnType} {method.MethodName}({parameters})
    {{
{tags}

        var stopwatch = Stopwatch.StartNew();
        _methodCallsCounter.Add(1, tags);

        try
        {{
            {(hasReturn ? "var result = " : "")}{(method.IsAsync ? "await " : "")}{method.MethodName}Core({parameterNames});

            stopwatch.Stop();
            tags.Add(""status"", ""success"");
            _methodDurationHistogram.Record(stopwatch.ElapsedMilliseconds, tags);

            {(hasReturn ? "return result;" : "")}
        }}
        catch (Exception ex)
        {{
            stopwatch.Stop();
            tags.Add(""status"", ""error"");
            tags.Add(""error_type"", ex.GetType().Name);

            _methodErrorsCounter.Add(1, tags);
            _methodDurationHistogram.Record(stopwatch.ElapsedMilliseconds, tags);

            throw;
        }}
    }}

    // Implement your logic in this Core method
    private{(method.IsAsync ? " async" : "")} partial {method.ReturnType} {method.MethodName}Core({parameters});
}}");

        return sb.ToString();
    }

    private static string ToSnakeCase(string text)
    {
        if (string.IsNullOrEmpty(text)) return text;

        var sb = new StringBuilder();
        sb.Append(char.ToLowerInvariant(text[0]));

        for (int i = 1; i < text.Length; i++)
        {
            char c = text[i];
            if (char.IsUpper(c))
            {
                sb.Append('_');
                sb.Append(char.ToLowerInvariant(c));
            }
            else
            {
                sb.Append(c);
            }
        }

        return sb.ToString();
    }

    private struct ClassInfo
    {
        public string Namespace { get; set; }
        public string ClassName { get; set; }
        public string MeterName { get; set; }
    }

    private struct InstrumentedMethodInfo
    {
        public string Namespace { get; set; }
        public string ClassName { get; set; }
        public string MethodName { get; set; }
        public string ReturnType { get; set; }
        public List<ParameterInfo> Parameters { get; set; }
        public List<string> TagParameters { get; set; }
        public bool IsAsync { get; set; }
    }

    private struct ParameterInfo
    {
        public string Type { get; set; }
        public string Name { get; set; }
    }
}
