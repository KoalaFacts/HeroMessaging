// Copyright (c) HeroMessaging Contributors. All rights reserved.

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Linq;
using System.Text;

namespace HeroMessaging.SourceGenerators;

/// <summary>
/// Generates fluent builder classes for messages.
/// </summary>
[Generator]
public class MessageBuilderGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register attribute source
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("GenerateBuilderAttribute.g.cs", SourceText.From(AttributeSource, Encoding.UTF8));
        });

        // Find types with [GenerateBuilder] attribute
        var candidates = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsCandidateNode(node),
                transform: static (ctx, _) => GetSemanticTarget(ctx))
            .Where(static type => type is not null);

        // Generate builders
        context.RegisterSourceOutput(candidates, static (spc, type) =>
        {
            if (type is null) return;

            var source = GenerateBuilder(type);
            spc.AddSource($"{type.Name}Builder.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private static bool IsCandidateNode(SyntaxNode node)
    {
        return node is TypeDeclarationSyntax typeDecl &&
               typeDecl.AttributeLists.Count > 0;
    }

    private static INamedTypeSymbol? GetSemanticTarget(GeneratorSyntaxContext context)
    {
        var typeDecl = (TypeDeclarationSyntax)context.Node;

        if (context.SemanticModel.GetDeclaredSymbol(typeDecl) is not INamedTypeSymbol symbol) return null;

        // Check for [GenerateBuilder] attribute
        var hasAttribute = symbol.GetAttributes()
            .Any(attr => attr.AttributeClass?.Name == "GenerateBuilderAttribute" ||
                        attr.AttributeClass?.Name == "GenerateBuilder");

        return hasAttribute ? symbol : null;
    }

    private static string GenerateBuilder(INamedTypeSymbol type)
    {
        var namespaceName = type.ContainingNamespace.ToDisplayString();
        var typeName = type.Name;
        var builderName = $"{typeName}Builder";

        // Get settable properties
        var properties = type.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => !p.IsStatic && p.DeclaredAccessibility == Accessibility.Public)
            .Where(p => p.SetMethod is not null || p.IsInitOnly())
            .ToList();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Fluent builder for {typeName}.");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"public sealed class {builderName}");
        sb.AppendLine("{");

        // Private fields for each property
        foreach (var prop in properties)
        {
            var propType = prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            sb.AppendLine($"    private {propType} _{ToCamelCase(prop.Name)};");
        }

        sb.AppendLine();

        // Private constructor
        sb.AppendLine($"    private {builderName}() {{ }}");
        sb.AppendLine();

        // Static New() method
        sb.AppendLine($"    public static {builderName} New() => new();");
        sb.AppendLine();

        // With methods for each property
        foreach (var prop in properties)
        {
            var propType = prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var paramName = ToCamelCase(prop.Name);

            sb.AppendLine($"    public {builderName} With{prop.Name}({propType} {paramName})");
            sb.AppendLine("    {");
            sb.AppendLine($"        _{paramName} = {paramName};");
            sb.AppendLine("        return this;");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        // Build method
        sb.AppendLine($"    public {typeName} Build()");
        sb.AppendLine("    {");
        sb.AppendLine($"        return new {typeName}");
        sb.AppendLine("        {");

        for (int i = 0; i < properties.Count; i++)
        {
            var prop = properties[i];
            var comma = i < properties.Count - 1 ? "," : string.Empty;
            sb.AppendLine($"            {prop.Name} = _{ToCamelCase(prop.Name)}{comma}");
        }

        sb.AppendLine("        };");
        sb.AppendLine("    }");

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        return char.ToLowerInvariant(name[0]) + name[1..];
    }

    private const string AttributeSource = @"// <auto-generated/>
namespace HeroMessaging.SourceGeneration
{
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
    internal sealed class GenerateBuilderAttribute : System.Attribute
    {
    }
}";
}

internal static class PropertySymbolExtensions
{
    public static bool IsInitOnly(this IPropertySymbol property)
    {
        return property.SetMethod?.IsInitOnly == true;
    }
}
