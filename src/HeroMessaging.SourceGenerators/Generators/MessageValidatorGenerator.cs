// Copyright (c) HeroMessaging Contributors. All rights reserved.

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Linq;
using System.Text;

namespace HeroMessaging.SourceGenerators;

/// <summary>
/// Generates validator classes from data annotation attributes.
/// </summary>
[Generator]
public class MessageValidatorGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register attribute source
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("GenerateValidatorAttribute.g.cs", SourceText.From(AttributeSource, Encoding.UTF8));
        });

        // Find types with [GenerateValidator] attribute
        var candidates = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsCandidateNode(node),
                transform: static (ctx, _) => GetSemanticTarget(ctx))
            .Where(static type => type is not null);

        // Generate validators
        context.RegisterSourceOutput(candidates, static (spc, type) =>
        {
            if (type is null) return;

            var source = GenerateValidator(type);
            spc.AddSource($"{type.Name}Validator.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private static bool IsCandidateNode(SyntaxNode node)
    {
        return node is TypeDeclarationSyntax typeDecl &&
               typeDecl.AttributeLists.Count > 0;
    }

    private static INamedTypeSymbol? GetSemanticTarget(GeneratorSyntaxContext context)
    {
        var typeDecl = (TypeDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(typeDecl) as INamedTypeSymbol;

        if (symbol is null) return null;

        // Check for [GenerateValidator] attribute
        var hasAttribute = symbol.GetAttributes()
            .Any(attr => attr.AttributeClass?.Name == "GenerateValidatorAttribute" ||
                        attr.AttributeClass?.Name == "GenerateValidator");

        return hasAttribute ? symbol : null;
    }

    private static string GenerateValidator(INamedTypeSymbol type)
    {
        var namespaceName = type.ContainingNamespace.ToDisplayString();
        var typeName = type.Name;
        var validatorName = $"{typeName}Validator";

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.ComponentModel.DataAnnotations;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Auto-generated validator for {typeName}.");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"public sealed class {validatorName}");
        sb.AppendLine("{");

        // Validate method
        sb.AppendLine($"    public static ValidationResult Validate({typeName} message)");
        sb.AppendLine("    {");
        sb.AppendLine("        var context = new ValidationContext(message);");
        sb.AppendLine("        var results = new List<ValidationResult>();");
        sb.AppendLine();
        sb.AppendLine("        if (Validator.TryValidateObject(message, context, results, validateAllProperties: true))");
        sb.AppendLine("        {");
        sb.AppendLine("            return ValidationResult.Success!;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        var errors = string.Join(\"; \", results.Select(r => r.ErrorMessage));");
        sb.AppendLine("        return new ValidationResult($\"Validation failed: {errors}\");");
        sb.AppendLine("    }");
        sb.AppendLine();

        // ValidateAndThrow method
        sb.AppendLine($"    public static void ValidateAndThrow({typeName} message)");
        sb.AppendLine("    {");
        sb.AppendLine("        var result = Validate(message);");
        sb.AppendLine("        if (result != ValidationResult.Success)");
        sb.AppendLine("        {");
        sb.AppendLine("            throw new ValidationException(result.ErrorMessage);");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();

        // IsValid method
        sb.AppendLine($"    public static bool IsValid({typeName} message)");
        sb.AppendLine("    {");
        sb.AppendLine("        return Validate(message) == ValidationResult.Success;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // GetValidationErrors method
        sb.AppendLine($"    public static IReadOnlyList<ValidationResult> GetValidationErrors({typeName} message)");
        sb.AppendLine("    {");
        sb.AppendLine("        var context = new ValidationContext(message);");
        sb.AppendLine("        var results = new List<ValidationResult>();");
        sb.AppendLine("        Validator.TryValidateObject(message, context, results, validateAllProperties: true);");
        sb.AppendLine("        return results;");
        sb.AppendLine("    }");

        sb.AppendLine("}");

        return sb.ToString();
    }

    private const string AttributeSource = @"// <auto-generated/>
namespace HeroMessaging.SourceGeneration
{
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
    internal sealed class GenerateValidatorAttribute : System.Attribute
    {
    }
}";
}
