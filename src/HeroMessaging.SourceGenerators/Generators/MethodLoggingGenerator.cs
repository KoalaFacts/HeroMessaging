// Copyright (c) HeroMessaging Contributors. All rights reserved.

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace HeroMessaging.SourceGenerators.Generators;

/// <summary>
/// Generates logging code for methods decorated with [LogMethod].
/// Creates partial method implementations with entry/exit/duration/error logging.
/// </summary>
[Generator]
public class MethodLoggingGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the attribute
        context.RegisterPostInitializationOutput(ctx =>
        {
            // LoggingAttributes.cs is already in the Attributes folder
        });

        // Find methods with [LogMethod]
        var methodDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsMethodWithLogAttribute(node),
                transform: static (ctx, _) => GetMethodInfo(ctx))
            .Where(static m => m is not null);

        // Generate logging implementations
        context.RegisterSourceOutput(methodDeclarations, (spc, method) =>
        {
            if (method is null) return;

            var source = GenerateLoggingMethod(method.Value);
            spc.AddSource($"{method.Value.ClassName}.{method.Value.MethodName}.Logging.g.cs",
                SourceText.From(source, Encoding.UTF8));
        });
    }

    private static bool IsMethodWithLogAttribute(SyntaxNode node)
    {
        return node is MethodDeclarationSyntax method &&
               method.AttributeLists.Count > 0 &&
               method.Modifiers.Any(m => m.ValueText == "partial");
    }

    private static MethodInfo? GetMethodInfo(GeneratorSyntaxContext context)
    {
        var method = (MethodDeclarationSyntax)context.Node;

        var classDeclaration = method.FirstAncestorOrSelf<ClassDeclarationSyntax>();
        if (classDeclaration is null) return null;

        var namespaceDeclaration = classDeclaration.FirstAncestorOrSelf<NamespaceDeclarationSyntax>();
        var namespaceName = namespaceDeclaration?.Name.ToString() ?? "Global";

        return new MethodInfo
        {
            Namespace = namespaceName,
            ClassName = classDeclaration.Identifier.Text,
            MethodName = method.Identifier.Text,
            ReturnType = method.ReturnType.ToString(),
            Parameters = method.ParameterList.Parameters
                .Select(p => new ParameterInfo
                {
                    Type = p.Type?.ToString() ?? "object",
                    Name = p.Identifier.Text,
                    HasNoLog = p.AttributeLists
                        .SelectMany(al => al.Attributes)
                        .Any(a => a.Name.ToString().Contains("NoLog"))
                })
                .ToList(),
            IsAsync = method.Modifiers.Any(m => m.ValueText == "async")
        };
    }

    private static string GenerateLoggingMethod(MethodInfo method)
    {
        var hasReturn = method.ReturnType != "void" && method.ReturnType != "Task";
        var parameters = string.Join(", ", method.Parameters.Select(p => $"{p.Type} {p.Name}"));
        var parameterNames = string.Join(", ", method.Parameters.Select(p => p.Name));

        var logParameters = method.Parameters
            .Where(p => !p.HasNoLog)
            .Select(p => $"{{{p.Name}}}")
            .ToList();

        var logArguments = method.Parameters
            .Where(p => !p.HasNoLog)
            .Select(p => p.Name)
            .ToList();

        var entryMessage = $"Entering {method.MethodName}";
        if (logParameters.Any())
        {
            entryMessage += $" with {string.Join(", ", method.Parameters.Where(p => !p.HasNoLog).Select(p => $"{p.Name}={{{p.Name}}}"))}";
        }

        var exitMessage = $"Completed {method.MethodName} in {{DurationMs}}ms";

        var sb = new StringBuilder();
        sb.AppendLine($@"// <auto-generated/>
#nullable enable

using System;
using System.Diagnostics;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace {method.Namespace};

public partial class {method.ClassName}
{{
    // Generated logging implementation for {method.MethodName}
    public{(method.IsAsync ? " async" : "")} partial {method.ReturnType} {method.MethodName}({parameters})
    {{
        using var activity = Activity.Current?.Source.StartActivity(""{method.ClassName}.{method.MethodName}"");
        var stopwatch = Stopwatch.StartNew();

        _logger.LogInformation(""{entryMessage}""{(logArguments.Any() ? ", " + string.Join(", ", logArguments) : "")});

        try
        {{
            {(hasReturn ? "var result = " : "")}{(method.IsAsync ? "await " : "")}{method.MethodName}Core({parameterNames});

            stopwatch.Stop();
            _logger.LogInformation(""{exitMessage}"", stopwatch.ElapsedMilliseconds);

            {(hasReturn ? "return result;" : "")}
        }}
        catch (Exception ex)
        {{
            stopwatch.Stop();
            _logger.LogError(ex, ""Failed {method.MethodName} after {{DurationMs}}ms"", stopwatch.ElapsedMilliseconds);
            throw;
        }}
    }}

    // Implement your logic in this Core method
    private{(method.IsAsync ? " async" : "")} partial {method.ReturnType} {method.MethodName}Core({parameters});
}}");

        return sb.ToString();
    }

    private struct MethodInfo
    {
        public string Namespace { get; set; }
        public string ClassName { get; set; }
        public string MethodName { get; set; }
        public string ReturnType { get; set; }
        public List<ParameterInfo> Parameters { get; set; }
        public bool IsAsync { get; set; }
    }

    private struct ParameterInfo
    {
        public string Type { get; set; }
        public string Name { get; set; }
        public bool HasNoLog { get; set; }
    }
}
