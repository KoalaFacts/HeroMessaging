namespace HeroMessaging.SourceGenerators;

/// <summary>
/// Generates extension methods to auto-register all handlers in an assembly.
/// </summary>
[Generator]
public class HandlerRegistrationGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all handler types in the compilation
        var handlers = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsCandidateNode(node),
                transform: static (ctx, _) => GetHandlerInfo(ctx))
            .Where(static info => info is not null)
            .Collect();

        // Generate registration extension method
        context.RegisterSourceOutput(handlers, static (spc, handlerInfos) =>
        {
            if (!handlerInfos.Any()) return;

            var source = GenerateRegistrationExtensions(handlerInfos!);
            spc.AddSource("HandlerRegistrationExtensions.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private static bool IsCandidateNode(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDecl &&
               !classDecl.Modifiers.Any(m => m.IsKind(SyntaxKind.AbstractKeyword)) &&
               classDecl.BaseList is not null;
    }

    private static HandlerInfo? GetHandlerInfo(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;

        if (symbol is null || symbol.IsAbstract) return null;

        // Check if implements any handler interface
        var handlerInterfaces = symbol.AllInterfaces
            .Where(i => i.Name.Contains("Handler"))
            .ToList();

        if (!handlerInterfaces.Any()) return null;

        return new HandlerInfo
        {
            TypeName = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            ClassName = symbol.Name,
            Namespace = symbol.ContainingNamespace.ToDisplayString(),
            Interfaces = handlerInterfaces
                .Select(i => i.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
                .ToArray()
        };
    }

    private static string GenerateRegistrationExtensions(ImmutableArray<HandlerInfo?> handlerInfos)
    {
        var handlers = handlerInfos.Where(h => h is not null).ToList();
        if (!handlers.Any()) return string.Empty;

        // Group by namespace to determine best namespace for extension
        var commonNamespace = handlers
            .Select(h => h!.Namespace)
            .GroupBy(ns => ns)
            .OrderByDescending(g => g.Count())
            .First()
            .Key;

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();
        sb.AppendLine($"namespace {commonNamespace};");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Auto-generated handler registration extensions.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class GeneratedHandlerRegistrationExtensions");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Registers all {handlers.Count} discovered handlers in this assembly.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static IServiceCollection AddGeneratedHandlers(this IServiceCollection services)");
        sb.AppendLine("    {");

        foreach (var handler in handlers)
        {
            if (handler is null) continue;

            foreach (var interfaceType in handler.Interfaces)
            {
                sb.AppendLine($"        services.AddTransient(typeof({interfaceType}), typeof({handler.TypeName}));");
            }
        }

        sb.AppendLine();
        sb.AppendLine("        return services;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private class HandlerInfo
    {
        public string TypeName { get; set; } = string.Empty;
        public string ClassName { get; set; } = string.Empty;
        public string Namespace { get; set; } = string.Empty;
        public string[] Interfaces { get; set; } = Array.Empty<string>();
    }
}
